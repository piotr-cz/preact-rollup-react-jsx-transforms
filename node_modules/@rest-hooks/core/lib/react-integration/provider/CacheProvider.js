import _jsx from "@babel/runtime/helpers/esm/jsx";
import masterReducer, { initialState as defaultState } from "../../state/reducer";
import NetworkManager from "../../state/NetworkManager";
import useEnhancedReducer from '@rest-hooks/use-enhanced-reducer';
import React, { useEffect, useMemo } from 'react';
import { useRef } from 'react';
import { StateContext, DispatchContext, DenormalizeCacheContext } from '../context';

/** Controller managing state of the REST cache and coordinating network requests. */
export default function CacheProvider({
  children,
  managers,
  initialState
}) {
  const denormalizeCache = useRef({
    entities: {},
    results: {}
  });
  const [state, dispatch] = useEnhancedReducer(masterReducer, initialState, managers.map(manager => manager.getMiddleware()));
  const optimisticState = useMemo(() => state.optimistic.reduce(masterReducer, state), [state]); // if we change out the manager we need to make sure it has no hanging async

  useEffect(() => {
    for (let i = 0; i < managers.length; ++i) {
      var _managers$i$init, _managers$i;

      (_managers$i$init = (_managers$i = managers[i]).init) === null || _managers$i$init === void 0 ? void 0 : _managers$i$init.call(_managers$i, state);
    }

    return () => {
      for (let i = 0; i < managers.length; ++i) {
        managers[i].cleanup();
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, managers);
  return /*#__PURE__*/_jsx(DispatchContext.Provider, {
    value: dispatch
  }, void 0, /*#__PURE__*/_jsx(StateContext.Provider, {
    value: optimisticState
  }, void 0, /*#__PURE__*/_jsx(DenormalizeCacheContext.Provider, {
    value: denormalizeCache.current
  }, void 0, children)));
}
CacheProvider.defaultProps = {
  managers: [new NetworkManager()],
  initialState: defaultState
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFjdC1pbnRlZ3JhdGlvbi9wcm92aWRlci9DYWNoZVByb3ZpZGVyLnRzeCJdLCJuYW1lcyI6WyJtYXN0ZXJSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwiZGVmYXVsdFN0YXRlIiwiTmV0d29ya01hbmFnZXIiLCJ1c2VFbmhhbmNlZFJlZHVjZXIiLCJSZWFjdCIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJTdGF0ZUNvbnRleHQiLCJEaXNwYXRjaENvbnRleHQiLCJEZW5vcm1hbGl6ZUNhY2hlQ29udGV4dCIsIkNhY2hlUHJvdmlkZXIiLCJjaGlsZHJlbiIsIm1hbmFnZXJzIiwiZGVub3JtYWxpemVDYWNoZSIsImVudGl0aWVzIiwicmVzdWx0cyIsInN0YXRlIiwiZGlzcGF0Y2giLCJtYXAiLCJtYW5hZ2VyIiwiZ2V0TWlkZGxld2FyZSIsIm9wdGltaXN0aWNTdGF0ZSIsIm9wdGltaXN0aWMiLCJyZWR1Y2UiLCJpIiwibGVuZ3RoIiwiaW5pdCIsImNsZWFudXAiLCJjdXJyZW50IiwiZGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiO0FBQUEsT0FBT0EsYUFBUCxJQUNFQyxZQUFZLElBQUlDLFlBRGxCLFFBRU8scUJBRlA7QUFHQSxPQUFPQyxjQUFQLE1BQTJCLDRCQUEzQjtBQUVBLE9BQU9DLGtCQUFQLE1BQStCLGtDQUEvQjtBQUNBLE9BQU9DLEtBQVAsSUFBMkJDLFNBQTNCLEVBQXNDQyxPQUF0QyxRQUFxRCxPQUFyRDtBQUNBLFNBQVNDLE1BQVQsUUFBdUIsT0FBdkI7QUFFQSxTQUNFQyxZQURGLEVBRUVDLGVBRkYsRUFHRUMsdUJBSEYsUUFJTyxZQUpQOztBQVlBO0FBQ0EsZUFBZSxTQUFTQyxhQUFULENBQXVCO0FBQ3BDQyxFQUFBQSxRQURvQztBQUVwQ0MsRUFBQUEsUUFGb0M7QUFHcENiLEVBQUFBO0FBSG9DLENBQXZCLEVBSUc7QUFDaEIsUUFBTWMsZ0JBQWdCLEdBQUdQLE1BQU0sQ0FBQztBQUM5QlEsSUFBQUEsUUFBUSxFQUFFLEVBRG9CO0FBRTlCQyxJQUFBQSxPQUFPLEVBQUU7QUFGcUIsR0FBRCxDQUEvQjtBQUlBLFFBQU0sQ0FBQ0MsS0FBRCxFQUFRQyxRQUFSLElBQW9CZixrQkFBa0IsQ0FDMUNKLGFBRDBDLEVBRTFDQyxZQUYwQyxFQUcxQ2EsUUFBUSxDQUFDTSxHQUFULENBQWFDLE9BQU8sSUFBSUEsT0FBTyxDQUFDQyxhQUFSLEVBQXhCLENBSDBDLENBQTVDO0FBTUEsUUFBTUMsZUFBZSxHQUFHaEIsT0FBTyxDQUM3QixNQUFNVyxLQUFLLENBQUNNLFVBQU4sQ0FBaUJDLE1BQWpCLENBQXdCekIsYUFBeEIsRUFBdUNrQixLQUF2QyxDQUR1QixFQUU3QixDQUFDQSxLQUFELENBRjZCLENBQS9CLENBWGdCLENBZ0JoQjs7QUFDQVosRUFBQUEsU0FBUyxDQUFDLE1BQU07QUFDZCxTQUFLLElBQUlvQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHWixRQUFRLENBQUNhLE1BQTdCLEVBQXFDLEVBQUVELENBQXZDLEVBQTBDO0FBQUE7O0FBQ3hDLHlDQUFBWixRQUFRLENBQUNZLENBQUQsQ0FBUixFQUFZRSxJQUFaLHdGQUFtQlYsS0FBbkI7QUFDRDs7QUFDRCxXQUFPLE1BQU07QUFDWCxXQUFLLElBQUlRLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdaLFFBQVEsQ0FBQ2EsTUFBN0IsRUFBcUMsRUFBRUQsQ0FBdkMsRUFBMEM7QUFDeENaLFFBQUFBLFFBQVEsQ0FBQ1ksQ0FBRCxDQUFSLENBQVlHLE9BQVo7QUFDRDtBQUNGLEtBSkQsQ0FKYyxDQVNkO0FBQ0QsR0FWUSxFQVVOZixRQVZNLENBQVQ7QUFZQSxzQkFDRSxLQUFDLGVBQUQsQ0FBaUIsUUFBakI7QUFBMEIsSUFBQSxLQUFLLEVBQUVLO0FBQWpDLDBCQUNFLEtBQUMsWUFBRCxDQUFjLFFBQWQ7QUFBdUIsSUFBQSxLQUFLLEVBQUVJO0FBQTlCLDBCQUNFLEtBQUMsdUJBQUQsQ0FBeUIsUUFBekI7QUFBa0MsSUFBQSxLQUFLLEVBQUVSLGdCQUFnQixDQUFDZTtBQUExRCxhQUNHakIsUUFESCxDQURGLENBREYsQ0FERjtBQVNEO0FBQ0RELGFBQWEsQ0FBQ21CLFlBQWQsR0FBNkI7QUFDM0JqQixFQUFBQSxRQUFRLEVBQUUsQ0FBQyxJQUFJWCxjQUFKLEVBQUQsQ0FEaUI7QUFFM0JGLEVBQUFBLFlBQVksRUFBRUM7QUFGYSxDQUE3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtYXN0ZXJSZWR1Y2VyLCB7XG4gIGluaXRpYWxTdGF0ZSBhcyBkZWZhdWx0U3RhdGUsXG59IGZyb20gJ0ByZXN0LWhvb2tzL2NvcmUvc3RhdGUvcmVkdWNlcic7XG5pbXBvcnQgTmV0d29ya01hbmFnZXIgZnJvbSAnQHJlc3QtaG9va3MvY29yZS9zdGF0ZS9OZXR3b3JrTWFuYWdlcic7XG5pbXBvcnQgeyBTdGF0ZSwgTWFuYWdlciB9IGZyb20gJ0ByZXN0LWhvb2tzL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHVzZUVuaGFuY2VkUmVkdWNlciBmcm9tICdAcmVzdC1ob29rcy91c2UtZW5oYW5jZWQtcmVkdWNlcic7XG5pbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlLCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7XG4gIFN0YXRlQ29udGV4dCxcbiAgRGlzcGF0Y2hDb250ZXh0LFxuICBEZW5vcm1hbGl6ZUNhY2hlQ29udGV4dCxcbn0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmludGVyZmFjZSBQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcbiAgbWFuYWdlcnM6IE1hbmFnZXJbXTtcbiAgaW5pdGlhbFN0YXRlOiBTdGF0ZTx1bmtub3duPjtcbn1cblxuLyoqIENvbnRyb2xsZXIgbWFuYWdpbmcgc3RhdGUgb2YgdGhlIFJFU1QgY2FjaGUgYW5kIGNvb3JkaW5hdGluZyBuZXR3b3JrIHJlcXVlc3RzLiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FjaGVQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBtYW5hZ2VycyxcbiAgaW5pdGlhbFN0YXRlLFxufTogUHJvdmlkZXJQcm9wcykge1xuICBjb25zdCBkZW5vcm1hbGl6ZUNhY2hlID0gdXNlUmVmKHtcbiAgICBlbnRpdGllczoge30sXG4gICAgcmVzdWx0czoge30sXG4gIH0pO1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZUVuaGFuY2VkUmVkdWNlcihcbiAgICBtYXN0ZXJSZWR1Y2VyLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBtYW5hZ2Vycy5tYXAobWFuYWdlciA9PiBtYW5hZ2VyLmdldE1pZGRsZXdhcmUoKSksXG4gICk7XG5cbiAgY29uc3Qgb3B0aW1pc3RpY1N0YXRlID0gdXNlTWVtbyhcbiAgICAoKSA9PiBzdGF0ZS5vcHRpbWlzdGljLnJlZHVjZShtYXN0ZXJSZWR1Y2VyLCBzdGF0ZSksXG4gICAgW3N0YXRlXSxcbiAgKTtcblxuICAvLyBpZiB3ZSBjaGFuZ2Ugb3V0IHRoZSBtYW5hZ2VyIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0IGhhcyBubyBoYW5naW5nIGFzeW5jXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hZ2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgbWFuYWdlcnNbaV0uaW5pdD8uKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWFuYWdlcnNbaV0uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBtYW5hZ2Vycyk7XG5cbiAgcmV0dXJuIChcbiAgICA8RGlzcGF0Y2hDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtkaXNwYXRjaH0+XG4gICAgICA8U3RhdGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtvcHRpbWlzdGljU3RhdGV9PlxuICAgICAgICA8RGVub3JtYWxpemVDYWNoZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2Rlbm9ybWFsaXplQ2FjaGUuY3VycmVudH0+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0Rlbm9ybWFsaXplQ2FjaGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9TdGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9EaXNwYXRjaENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5DYWNoZVByb3ZpZGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgbWFuYWdlcnM6IFtuZXcgTmV0d29ya01hbmFnZXIoKV0gYXMgTWFuYWdlcltdLFxuICBpbml0aWFsU3RhdGU6IGRlZmF1bHRTdGF0ZSBhcyBTdGF0ZTx1bmtub3duPixcbn07XG4iXX0=